## 4강: 재귀 알고리즘(Recursive Algorithms) - 기초

### 재귀함수(recursive functions)
* 재귀 알고리즘은 재귀함수에 의해서 구현. 많은 종류의 문제가 재귀적으로 해결 가능.
* **재귀함수**: 하나의 함수에서 자신을 다시 호출하여 작업을 수행하는 것
  * 재귀함수 예1) **이진트리(binary trees)**
    * 왼쪽 서브트리의 원소들은 모두 작거나 같고, 오른쪽 서브트리의 원소들은 모두 클 것
    * 이 원칙을 모든 노드에 대해서 적용 
* 알고리즘은 유한한 시간 안에 답을 내야 하므로 알고리즘의 종결 조건을 명시하는 것에 주의.
  * 재귀함수 예2) **자연수의 합 구하기**
    * 문제: 1부터 n까지 모든 자연수의 합을 구하시오.
    ```python
    def sum(n):
      if n <= 1:
        return n
      else:
        return n + sum(n - 1)
    ```
  * 재귀함수 예3) **n!**
    * 문제: 1부터 n까지 곱한 수
    ```python
    def what(n):
      if n <= 1:
        return 1
      else:
        return n * what(n - 1)
    ```    

### 재귀 알고리즘의 효율
* 모든 재귀알고리즘은 그와 대칭을 이루는 카운터 파트너인 반복적인 알고리즘이 존재
  * **Recursive version**
    * n이 커지면 n에 따라서 함수를 호출해야 하는 횟수가 커지므로 n에 비례하는 시간복잡도 `O(n)` 
  ```python
  def sum(n):
    if n <= 1:
      return n
    else:
      return n + sum(n - 1)
  ```
  * **Iterative version**
    * n이 커지면 n에 비례하는 순환문 반복을 해야하므로 시간복잡도 `O(n)` 
  ```python
  def sum(n):
    s = 0
    while n >= 0:
      s += n
      n -= 1
    return s
  ```
* 시간복잡도는 `O(n)`으로 동일하지만 효율성의 측면에서 재귀 알고리즘은 n이 증가하면 n크기에 따라 함수를 호출하고 리턴하는 부가적인 작업이 필요하므로 반복 알고리즘보다 효율성이 떨어짐. 재귀 알고리즘은 사람이 생각하는 방식을 표현하기에 유리한 면도 있지만 효율성의 측면에서 고려해 봐야 함. 
  * **효율성이 좋은 예**) 1부터 n까지의 합 `O(1)`
  ```python
  def sum(n):
   return n * (n + 1) // 2
  ```
---
### 실습: 피보나치 순열
